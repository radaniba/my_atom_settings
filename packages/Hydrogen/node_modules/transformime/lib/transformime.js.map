{"version":3,"sources":["../src/transformime.js"],"names":[],"mappings":"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","file":"transformime.js","sourcesContent":["'use strict'\n\nimport { TextTransform } from './text.transform'\nimport { ImageTransform } from './image.transform'\nimport { HTMLTransform } from './html.transform'\n/**\n * Transforms mimetypes into HTMLElements\n */\nclass Transformime {\n\n  /**\n   * Public constructor\n   * @param  {function[]} transformers - list of transformers, in reverse priority order.\n   */\n  constructor (transformers) {\n    // Initialize instance variables.\n    this.transformers = []\n    this.push(TextTransform)\n    this.push(ImageTransform)\n    this.push(HTMLTransform)\n    if (transformers) transformers.forEach((transformer) => { this.push(transformer) })\n  }\n  /**\n   * Transforms a mime bundle, using the richest available representation,\n   * into an HTMLElement.\n   * @param  {any}      bundle - {mimetype1: data1, mimetype2: data2, ...}\n   * @param  {Document} document - Any of window.document, iframe.contentDocument\n   * @return {Promise<{mimetype: string, el: HTMLElement}>}\n   */\n  transform (bundle, document) {\n    if (this.transformers.length <= 0) {\n      // Empty transformers\n      return Promise.reject(new Error('No transformers configured'))\n    }\n\n    if (Object.keys(bundle).length <= 0) {\n      return Promise.reject(new Error('MIME Bundle empty'))\n    }\n\n    let richMimetype\n    let richTransformer\n\n    // Choose the last transformer as the most rich\n    for (let transformer of this.transformers) {\n      if (transformer.mimetype) {\n        // Make sure the transformer's mimetype is in array format.\n        let transformer_mimetypes = transformer.mimetype\n        if (!Array.isArray(transformer_mimetypes)) {\n          transformer_mimetypes = [transformer_mimetypes]\n        }\n\n        for (let transformer_mimetype of transformer_mimetypes) {\n          if (transformer_mimetype in bundle) {\n            richMimetype = transformer_mimetype\n            richTransformer = transformer\n          }\n        }\n      }\n    }\n\n    if (richMimetype && richTransformer) {\n      // Don't assume the transformation will return a promise.  Also\n      // don't assume the transformation will succeed.\n      try {\n        return Promise.resolve(richTransformer.call(richTransformer,\n          richMimetype, bundle[richMimetype], document)).then(el => {\n            return { mimetype: richMimetype, el: el }\n          })\n      } catch (e) {\n        return Promise.reject(e)\n      }\n    } else {\n      return Promise.reject(new Error('Transformer(s) for ' + Object.keys(bundle).join(', ') + ' not found.'))\n    }\n  }\n\n  /**\n   * Deletes all transformers by mimetype.\n   * @param {string|string[]} mimetype - mimetype the data type (e.g. text/plain, text/html, image/png)\n   */\n  del (mimetype) {\n    // Convert mimetype to an array.\n    let mimetypes = mimetype\n    if (!Array.isArray(mimetypes)) {\n      mimetypes = [mimetypes]\n    }\n\n    // Remove each mimetype.\n    for (mimetype of mimetypes) {\n      for (let i = 0; i < this.transformers.length; i++) {\n        var transformer = this.transformers[i]\n\n        // If the mimetype matches the one we want to remove, remove it.\n        if (mimetype === transformer.mimetype) {\n          this.transformers.splice(i, 1)\n          i--\n\n        // If the mimetype we want to remove is in the list of the\n        // mimetypes supported by the transformer, remove it from the list.\n        // If the transformer mimetype list is then empty, remove the\n        // transformer.\n        } else if (Array.isArray(transformer.mimetype) && mimetype in transformer.mimetype) {\n          if (transformer.mimetype.length === 1) {\n            this.transformers.splice(i, 1)\n            i--\n          } else {\n            transformer.mimetype.splice(transformer.mimetype.indexOf(mimetype), 1)\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Gets a transformer matching the mimetype\n   * @param {string} mimetype - the data type (e.g. text/plain, text/html, image/png)\n   * @return {function} Matching transformer\n   */\n  get (mimetype) {\n    // Loop through the transformers array in reverse.\n    for (let i = this.transformers.length - 1; i >= 0; i--) {\n      let transformer = this.transformers[i]\n\n      // Get an array of the mimetypes that the transformer supports.\n      let transformer_mimetypes = transformer.mimetype\n      if (!Array.isArray(transformer_mimetypes)) {\n        transformer_mimetypes = [transformer_mimetypes]\n      }\n\n      // Check if any of the mimetypes match the one we are looking for.\n      for (let transformer_mimetype of transformer_mimetypes) {\n        if (mimetype === transformer_mimetype) {\n          return transformer\n        }\n      }\n    }\n  }\n\n  /**\n   * Sets a transformer matching the mimetype\n   * @param {string|string[]} mimetype - the data type (e.g. text/plain, text/html, image/png)\n   * @param {function} transformer\n   * @return {function} inserted transformer function (may be different than arg)\n   */\n  set (mimetype, transformer) {\n    this.del(mimetype)\n    return this.push(transformer, mimetype)\n  }\n\n  /**\n   * Appends a transformer to the transformer list.\n   * @param  {function} transformer\n   * @param  {string|string[]} mimetype\n   * @return {function} inserted transformer function (may be different than arg)\n   */\n  push (transformer, mimetype) {\n    // If the mimetype specified is different than the mimetype of the\n    // transformer, make a copy of the transformer and set the new mimetype\n    // on the copy.\n    let transform = transformer\n    if (mimetype && transformer.mimetype !== mimetype) {\n      transform = this._proxy(transformer, mimetype)\n    }\n\n    // Verify a mimetype is set on the transformer.\n    if (!transform.mimetype) throw Error('Could not infer transformer mimetype')\n\n    this.transformers.push(transform)\n    return transform\n  }\n\n  /**\n   * Create a proxy to a transformer, using another mimetype.\n   * @param  {function} transformer\n   * @param  {string|string[]} mimetype\n   * @return {function} transformer\n   */\n  _proxy (transformer, mimetype) {\n    let transform = function (...args) { return transformer.call(this, ...args) }\n    transform.mimetype = mimetype\n    return transform\n  }\n}\n\n/**\n* Helper to create a function that transforms a MIME bundle into an HTMLElement\n* using the given document and list of transformers.\n* @param  {function[]} [transformers] List of transformers, in reverse priority order.\n* @param  {Document}   [doc]          E.g. window.document, iframe.contentDocument\n* @return {function}\n*/\nfunction createTransform (transformers, doc) {\n  const t = new Transformime(transformers)\n\n  if (!doc) {\n      doc = document\n  }\n\n  /**\n   * Transforms a MIME bundle into an HTMLElement.\n   * @param  {object} bundle {mimetype1: data1, mimetype2: data2, ...}\n   * @return {Promise<{mimetype: string, el: HTMLElement}>}\n   */\n  return function transform(bundle) {\n    return t.transform(bundle, doc)\n  }\n}\n\nexport {\n    Transformime,\n    TextTransform,\n    TextTransform as TextTransformer,\n    ImageTransform,\n    ImageTransform as ImageTransformer,\n    HTMLTransform,\n    HTMLTransform as HTMLTransformer,\n    createTransform\n};\n"]}